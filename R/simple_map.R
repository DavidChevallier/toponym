#' @title Plots locations on a map
#' @description The function generates a map plotting all locations, filtered by \code{getCoordinates()}. The plot also displays additional information if used by \code{topCompOut()}
#' @param coordinates  coordinates with country codes and matched strings filtered by \code{getCoordinates()}
#' @param color character string. indicating, which color is assigned to each country code in order.
#' @param strings character string. In form of regular expression that filter the data frames. The first string is shown on the plot.
#' @param regions numeric. Specify the level of regional borders. By default \code{0} displaying only country borders.
#' @param plot logical. If \code{FALSE} then the plot will not be printed but saved as .png in the current working directory.
#' @param ratio_string character string. Ratio of occurrences in the polygon from \code{topComp()}.
#' @param fq character string. Number of occurrences in the designated polygon and in total.
#' @param lons numeric. Vector of longitudinal coordinates defining the polygon.
#' @param lats numeric. Vector of latitudinal coordinates defining the polygon.
#' @keywords internal
#' @import ggplot2
#' @return A plot in the current R session or as .png in the working directory. If directly generated by \code{top()}, it displays the first string and the total occurrences. If generated by \code{topCompOut()}, it displays the string, the ratio as a percentage and the number of occurrences in the designated polygon and in total.
simpleMap <- function(strings, coordinates, color, regions, plot, polygon, ratio_string, fq) {
  x <- coordinates[[1]] # latitude
  y <- coordinates[[2]] # longitude
  cc <- coordinates[[3]] # country code
  matches <- coordinates[[4]] # matched string

  nas <- unique(which(is.na(x)), which(is.na(y))) # checks for NAs
  if (length(nas) > 0) {
    x <- x[-nas]
    y <- y[-nas]
  }
  if (length(x) == 0 | length(y) == 0) {
    stop("\nThere are no coordinates to plot\n")
  }
  md <- cbind(as.numeric(x), as.numeric(y), cc, matches) %>% # creates df out of x and y coordinates
    as.data.frame() %>%
    mutate_at(c("V1", "V2"), as.numeric)

  # removes coordinates outside of the polygon

  if (!is.null(polygon)) {
    # store coordinates of the polygon in a df
    pol <- data.frame(X = polygon$lons, Y = polygon$lats)
    # chull function from package grDevices
    pos <- chull(pol)
    con.hull <- rbind(pol[pos, ], pol[pos[1], ]) # convex hull

    poly_log <- as.logical(point.in.polygon(md[, 2], md[, 1], con.hull$X, con.hull$Y)) # check which places are in the polygon

    md <- md[poly_log, ] # only those in the polygon left
  }



  # get max min long and lat and add a frame of 10% around the points
  lat_range <- range(md[, 1])
  lng_range <- range(md[, 2])
  lat_extend <- 0.1 * diff(lat_range)
  lng_extend <- 0.1 * diff(lng_range)
  lat_range <- c(lat_range - lat_extend, lat_range + lat_extend)
  lng_range <- c(lng_range - lng_extend, lng_range + lng_extend)
  # 	for (i in 1:4) {
  # 		if (lng_range[i] > 180) {lng_range[i] <- 180}
  # 		if (lng_range[i] < -180) {lng_range[i] <- -180}
  # 	}

  map_path <- paste0(system.file(package = "geodata"), "/extdata")
  if (regions == 0) {
    map <- world(path = map_path) # gets world map from pkg "geodata"
  } else {
    map <- gadm(country = unique(cc), level = regions, path = map_path) # gets map of specified countries with domestic borders from pkg "rnaturalearth"
    # if(!missing(region_name)){map <- map[map$NAME_1 %in% region_name,]}
  }



  map <- sf::st_as_sf(map) # converts map into simple features map

  lengths <- as.data.frame(table(md[, 4])) # frequencies of each string in the same order
  if (length(strings) == nrow(lengths)) { # if multiple toponyms (i.e. endings etc.) result from one string
    lengths <- lengths[match(gsub("[[:punct:]]", "", strings), lengths$Var1), ][, 2]
  } else if (length(strings) == 1) {
    lengths <- sum(lengths$Freq)
  } else { # if multiple strings are used, and one or more results in multiple toponyms
    lengths <- NULL
  }

  if (is.null(color)) {
    color <- rainbow(length(unique(md[, 4])))
  } else if (length(color) != length(unique(md[, 4]))) {
    stop("The number of colors does not match the number of toponyms for mapping. Try again with the default color palette.")
  }

  # creates plot
  p <- ggplot() +
    geom_sf(data = map) +
    theme_classic() +
    geom_point(data = md, mapping = aes(x = md[, 2], y = md[, 1], col = md[, 4])) +
    coord_sf(
      xlim = c(min(lng_range), max(lng_range)),
      ylim = c(min(lat_range), max(lat_range))
    ) +
    scale_color_manual(values = color) +
    labs(x = "longitude", y = "latitude", color = "string", title = paste(strings, lengths, collapse = "| ")) + # legend only with string & frequency
    {
      if (!is.null(ratio_string) && !is.null(fq)) labs(title = paste(strings, ratio_string, fq, collapse = " "))
    } # extended legend if created with topCompOut()


  # saves or prints plot
  if (plot == FALSE) {
    plot_name <- paste0("plot_", paste(regmatches(strings, regexpr("[a-zA-Z]+", strings)), collapse = "_"), ".png", collapse = "_")
    ggsave(plot_name, path = file.path(getwd(), "plots"))
    message(paste("\nPlot", plot_name, "saved in plots folder of the working directory.\n"))
  } else {
    print(p)
  }
}
