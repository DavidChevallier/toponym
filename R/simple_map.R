#' @title Plots toponyms onto a map
#' @description
#' This function generates a map plotting all locations, filtered by \code{getCoordinates()}.
#' @details
#' If directly generated by \code{top()}, it displays the strings and the total occurrences. If generated by \code{topCompOut()}, it displays the string, the ratio as a percentage and the number of occurrences in the designated polygon and in total.
#' @param coordinates  coordinates with country codes and matched strings filtered by \code{getCoordinates()}.
#' @param color character string indicating, which color is assigned to each string.
#' @param strings character string with regular expression to filter data.
#' @param regions numeric. Specifies the level of regional borders. By default \code{0} for displaying only country borders.
#' @param plot logical. If \code{FALSE}, then the plot will not be printed but saved as .png in the current working directory.
#' @param ... Addtional parameters:
#' \itemize{
#' \item\code{ratio_string} character string. Ratio of occurrences in the polygon from \code{topComp()}.
#' \item\code{fq} character string. Number of occurrences in the designated polygon and in total.
#' \item\code{legend_title} character string. Only if \code{mapper} is used. Text for the title of the legend. It is prioritized over `string` and `color` even if a `group` and `color` column exists.
#' }
#' @keywords internal
#' @return A plot of all selected toponyms.
simpleMap <- function(strings, coordinates, color, regions, plot, ...) {
  x <- coordinates$latitude
  y <- coordinates$longitude
  cc <- coordinates$`country code`
  group <- coordinates$`group`
  if(!is.numeric(regions)) stop("Parameter `regions` must be numeric.")
  if(!is.logical(plot)) stop("`plot` must be logical.")
  opt <- list(...)

  mapper_color <- is.null(coordinates$`color`) # checks if mapper data contains color
  mapper_l <- grepl("mapper", sys.calls()[[1]][1]) # checks if used by mapper
  if(all(!is.null(color), mapper_color, is.null(group))) {
    if(length(color) != length(x) && length(color) != 1) stop("Length of parameter `color` must be either equal to the number of points or 1 if no `group` column is given.")
  }

  nas <- unique(which(is.na(x)), which(is.na(y))) # checks for NAs
  if (length(nas) > 0) {
    x <- x[-nas]
    y <- y[-nas]
  }
  if (length(x) == 0 | length(y) == 0) {
    stop("\nThere are no coordinates to plot.\n")
  }
  md <- as.data.frame(cbind(as.numeric(x), as.numeric(y), cc, group)) # creates df out of x and y coordinates
  md$V1   <-  as.numeric(md$V1)
  md$V2   <-  as.numeric(md$V2)




  # get max min long and lat and add a frame of 10% around the points
  lat_range <- range(md$V1)
  lng_range <- range(md$V2)
  lat_extend <- 0.1 * diff(lat_range)
  lng_extend <- 0.1 * diff(lng_range)
  lat_range <- c(lat_range - lat_extend, lat_range + lat_extend)
  lng_range <- c(lng_range - lng_extend, lng_range + lng_extend)
  # 	for (i in 1:4) {
  # 		if (lng_range[i] > 180) {lng_range[i] <- 180}
  # 		if (lng_range[i] < -180) {lng_range[i] <- -180}
  # 	}

  map_path <- paste0(system.file(package = "geodata"), "/extdata")
  if (regions == 0) {
    map <- world(path = map_path) # gets world map from pkg "geodata"
  } else {
    map <- gadm(country = unique(cc), level = regions, path = map_path) # gets map of specified countries with domestic borders from pkg "geodata"
    # if(!missing(region_name)){map <- map[map$NAME_1 %in% region_name,]}
    if(is.null(map)) stop(paste("Map data could not be retrieved.", if(regions >= 1) "'regions' parameter may be set too high"))
  }



  map <- sf::st_as_sf(map) # converts map into simple features map

  if(!is.null(group)){ #if group are given
  lengths <- as.data.frame(table(md$group)) # frequencies of each string in the same order
  if (length(strings) == nrow(lengths)) { # if multiple toponyms (i.e. endings etc.) result from one string
    lengths <- lengths[match(gsub("[[:punct:]]", "", strings), lengths$Var1), ][, 2]
  } else if (length(strings) == 1) {
    lengths <- sum(lengths$Freq)
  } else { # if multiple strings are used, and one or more results in multiple toponyms
    lengths <- NULL
  }

  ########### colors
  if(mapper_color){ #if no color column exists in mapper data
  if (is.null(color)) color <- rainbow(length(unique(md$group)))

  if (length(color) != length(unique(md$group))) stop("The number of colors does not match the number of toponyms/groups for mapping.")
  }
  }

  #print(opt$legend_title)


  # creates plot
  if(mapper_color){ # TRUE if no mapper color column
  p <- ggplot() +
    geom_sf(data = map) +
    theme_classic() +
    geom_point(data = md, mapping = aes(x = md[,"V2"], y = md[,"V1"], col = if(!is.null(group)){group} else{color})) +
    coord_sf(
      xlim = c(min(lng_range), max(lng_range)),
      ylim = c(min(lat_range), max(lat_range))
    ) +
    scale_color_manual(values = color, limits = unique(group), name = if(!is.null(opt$legend_title)){opt$legend_title}else if(!is.null(group)){"string"} else("color")) +
    labs(x = "longitude", y = "latitude", title = paste(strings, if(!mapper_l){lengths}, collapse = "| ")) + # legend only with string & frequency
    {
      if (!is.null(opt$ratio_string) && !is.null(opt$fq)) labs(title = paste(strings, opt$ratio_string, opt$fq, collapse = " "))
    } # extended legend if created with topCompOut()

  } else if(!mapper_color){ # FALSE if mapper color column
  p <- ggplot() +
    geom_sf(data = map) +
    theme_classic() +
    geom_point(data = md, mapping = aes(x = md[,"V2"], y = md[,"V1"], col = if(!is.null(group)){group} else{coordinates$`color`})) +
    scale_color_manual(values = unique(coordinates$`color`), limits = if(!is.null(group)){unique(group)}else{unique(coordinates$`color`)}, name = if(!is.null(opt$legend_title)){opt$legend_title}else{"string"}) +
    coord_sf(
      xlim = c(min(lng_range), max(lng_range)),
      ylim = c(min(lat_range), max(lat_range))
    ) +
    labs(x = "longitude", y = "latitude", title = strings) # legend only with string & frequency
  }





  # saves or prints plot
  if (plot == FALSE) {
    plot_name <- paste0("plot_", paste(regmatches(strings, regexpr("[a-zA-Z]+", strings)), collapse = "_"), ".png", collapse = "_")
    ggsave(plot_name, path = file.path(getwd(), "plots"))
    message(paste("\nPlot", plot_name, "saved in `plots` folder of the working directory.\n"))
  } else {
    print(p)
  }
}
