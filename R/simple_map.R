#' @title Plots toponyms onto a map
#' @description
#' This function generates a map plotting all locations, filtered by \code{getCoordinates()}.
#' @details
#' If directly generated by \code{top()}, it displays the strings and the total occurrences. If generated by \code{topCompOut()}, it displays the string, the ratio as a percentage and the number of occurrences in the designated polygon and in total.
#' @param coordinates  coordinates with country codes and matched strings filtered by \code{getCoordinates()}.
#' @param color character string indicating, which color is assigned to each string.
#' @param strings character string with regular expression to filter data.
#' @param regions numeric. Specifies the level of regional borders. By default \code{0} for displaying only country borders.
#' @param plot logical. If \code{FALSE}, then the plot will not be printed but saved as .png in the current working directory.
#' @param ratio_string character string. Ratio of occurrences in the polygon from \code{topComp()}.
#' @param fq character string. Number of occurrences in the designated polygon and in total.
#' @keywords internal
#' @return A plot of all selected toponyms.
simpleMap <- function(strings, coordinates, color, regions, plot, ratio_string, fq) {

  x <- coordinates$latitude
  y <- coordinates$longitude
  cc <- coordinates$`country code`
  matches <- coordinates$`matches`
  mapper_color <- is.null(coordinates$`color`) # checks if mapper data contains colors
  mapper_l <- grepl("mapper", sys.calls()[[1]][1]) # checks if used by mapper
  nas <- unique(which(is.na(x)), which(is.na(y))) # checks for NAs
  if (length(nas) > 0) {
    x <- x[-nas]
    y <- y[-nas]
  }
  if (length(x) == 0 | length(y) == 0) {
    stop("\nThere are no coordinates to plot.\n")
  }
  md <- cbind(as.numeric(x), as.numeric(y), cc, matches) %>% # creates df out of x and y coordinates
    as.data.frame() %>%
    mutate_at(c("V1", "V2"), as.numeric)




  # get max min long and lat and add a frame of 10% around the points
  lat_range <- range(md[, 1])
  lng_range <- range(md[, 2])
  lat_extend <- 0.1 * diff(lat_range)
  lng_extend <- 0.1 * diff(lng_range)
  lat_range <- c(lat_range - lat_extend, lat_range + lat_extend)
  lng_range <- c(lng_range - lng_extend, lng_range + lng_extend)
  # 	for (i in 1:4) {
  # 		if (lng_range[i] > 180) {lng_range[i] <- 180}
  # 		if (lng_range[i] < -180) {lng_range[i] <- -180}
  # 	}

  map_path <- paste0(system.file(package = "geodata"), "/extdata")
  if (regions == 0) {
    map <- world(path = map_path) # gets world map from pkg "geodata"
  } else {
    map <- gadm(country = unique(cc), level = regions, path = map_path) # gets map of specified countries with domestic borders from pkg "rnaturalearth"
    # if(!missing(region_name)){map <- map[map$NAME_1 %in% region_name,]}
    if(is.null(map)) stop(paste("Map data could not be retrieved.", if(regions >= 1) "'regions' argument may be set too high"))
  }



  map <- sf::st_as_sf(map) # converts map into simple features map


  lengths <- as.data.frame(table(md[, 4])) # frequencies of each string in the same order
  if (length(strings) == nrow(lengths)) { # if multiple toponyms (i.e. endings etc.) result from one string
    lengths <- lengths[match(gsub("[[:punct:]]", "", strings), lengths$Var1), ][, 2]
  } else if (length(strings) == 1) {
    lengths <- sum(lengths$Freq)
  } else { # if multiple strings are used, and one or more results in multiple toponyms
    lengths <- NULL
  }


  ########### colors
  if(mapper_color){ #if no color column exists in mapper data
  if (is.null(color)) color <- rainbow(length(unique(md[, 4])))

  if (length(color) != length(unique(md[, 4]))) stop("The number of colors does not match the number of toponyms for mapping.")
  }

  # creates plot
  if(mapper_color){ # no mapper color column
  p <- ggplot() +
    geom_sf(data = map) +
    theme_classic() +
    geom_point(data = md, mapping = aes(x = md[, 2], y = md[, 1], col = md[, 4])) +
    coord_sf(
      xlim = c(min(lng_range), max(lng_range)),
      ylim = c(min(lat_range), max(lat_range))
    ) +
    scale_color_manual(values = color, limits = unique(md$matches)) +
    labs(x = "longitude", y = "latitude", color = "string", title = paste(strings, if(!mapper_l){lengths}, collapse = "| ")) + # legend only with string & frequency
    {
      if (!is.null(ratio_string) && !is.null(fq)) labs(title = paste(strings, ratio_string, fq, collapse = " "))
    } # extended legend if created with topCompOut()

  } else{ #mapper color column
  p <- ggplot() +
    geom_sf(data = map) +
    theme_classic() +
    geom_point(data = md, mapping = aes(x = md[, 2], y = md[, 1], col = coordinates$`color`)) +
    coord_sf(
      xlim = c(min(lng_range), max(lng_range)),
      ylim = c(min(lat_range), max(lat_range))
    ) +
    labs(x = "longitude", y = "latitude", color = "color", title = strings) # legend only with string & frequency
  }





  # saves or prints plot
  if (plot == FALSE) {
    plot_name <- paste0("plot_", paste(regmatches(strings, regexpr("[a-zA-Z]+", strings)), collapse = "_"), ".png", collapse = "_")
    ggsave(plot_name, path = file.path(getwd(), "plots"))
    message(paste("\nPlot", plot_name, "saved in plots folder of the working directory.\n"))
  } else {
    print(p)
  }
}
